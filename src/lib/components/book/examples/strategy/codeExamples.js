export const naivePaymentCode = [
  '// PaymentProcessor.naive.svelte',
  '',
  'let { payment } = $props();',
  'let result = $state(null);',
  '',
  '// Everything happens inline with nested conditionals',
  '$effect(() => {',
  "  if (payment.method === 'credit_card' && payment.requiresAuth) {",
  '    result = {',
  "      status: 'processing',",
  "      message: 'Redirecting to 3D Secure authentication...',",
  "      fee: payment.amount * (payment.processingFee / 100),",
  "      gateway: 'stripe'",
  '    };',
  "  } else if (payment.method === 'paypal' && payment.instantSettlement) {",
  '    result = {',
  "      status: 'redirect',",
  "      message: 'Express checkout with PayPal...',",
  "      fee: payment.amount * (payment.processingFee / 100),",
  "      gateway: 'paypal'",
  '    };',
  "  } else if (payment.method === 'crypto' && payment.currency === 'BTC') {",
  '    result = {',
  "      status: 'pending',",
  "      message: 'Generating Bitcoin wallet address...',",
  "      fee: payment.amount * (payment.processingFee / 100),",
  "      gateway: 'coinbase'",
  '    };',
  '  } else {',
  '    result = {',
  "      status: 'processing',",
  "      message: 'Processing payment...',",
  "      fee: 0,",
  "      gateway: 'default'",
  '    };',
  '  }',
  '});',
  '',
  '// Template mixes rendering + business logic',
  '<div class={`payment payment--${result?.status ?? "pending"}`}>',
  '  <h3>{result?.message}</h3>',
  '  <p>Fee: ${result?.fee?.toFixed(2)}</p>',
  '</div>'
].join('\n');

export const branchingPaymentCode = [
  '// PaymentProcessor.branching.svelte',
  '',
  'let { payment } = $props();',
  '',
  'function resolvePaymentType() {',
  "  if (payment.method === 'credit_card') return 'creditcard';",
  "  if (payment.method === 'paypal') return 'paypal';",
  "  if (payment.method === 'crypto') return 'crypto';",
  "  return 'default';",
  '}',
  '',
  'const paymentType = $derived(resolvePaymentType());',
  '',
  '// Still a massive switch statement inside the component',
  'const processing = $derived(() => {',
  '  switch (paymentType) {',
  "    case 'creditcard':",
  '      return {',
  "        status: 'processing',",
  "        message: 'Secure credit card processing...',",
  "        gateway: 'stripe',",
  "        requiresRedirect: payment.requiresAuth",
  '      };',
  "    case 'paypal':",
  '      return {',
  "        status: 'redirect',",
  "        message: 'PayPal Express checkout...',",
  "        gateway: 'paypal',",
  "        requiresRedirect: true",
  '      };',
  "    case 'crypto':",
  '      return {',
  "        status: 'pending',",
  "        message: 'Blockchain payment processing...',",
  "        gateway: 'coinbase',",
  "        requiresRedirect: false",
  '      };',
  '    default:',
  '      return {',
  "        status: 'processing',",
  "        message: 'Standard payment processing...',",
  "        gateway: 'default',",
  "        requiresRedirect: false",
  '      };',
  '  }',
  '});'
].join('\n');

export const configPaymentCode = [
  '// PaymentProcessor.config.svelte',
  '',
  'let { payment } = $props();',
  '',
  'const PAYMENT_CONFIGS = {',
  '  creditcard: {',
  "    gateway: 'stripe',",
  "    status: 'processing',",
  '    message: ({ amount, processingFee }) =>',
  '      `Processing $${amount} via credit card. ${processingFee}% fee applies.`,',
  "    requiresRedirect: true",
  '  },',
  '  paypal: {',
  "    gateway: 'paypal',",
  "    status: 'redirect',",
  '    message: ({ amount, processingFee }) =>',
  '      `$${amount} via PayPal Express. ${processingFee}% processing fee.`,',
  "    requiresRedirect: true",
  '  },',
  '  crypto: {',
  "    gateway: 'coinbase',",
  "    status: 'pending',",
  '    message: ({ amount, currency }) =>',
  '      `${amount} ${currency} blockchain payment. Network fees apply.`,',
  "    requiresRedirect: false",
  '  },',
  '  default: {',
  "    gateway: 'default',",
  "    status: 'processing',",
  "    message: () => 'Standard payment processing with basic validation.',",
  "    requiresRedirect: false",
  '  }',
  '};',
  '',
  'function determineType(data) {',
  "  if (data.method === 'credit_card') return 'creditcard';",
  "  if (data.method === 'paypal') return 'paypal';",
  "  if (data.method === 'crypto') return 'crypto';",
  "  return 'default';",
  '}',
  '',
  'const processing = $derived(() => {',
  '  const type = determineType(payment);',
  '  const config = PAYMENT_CONFIGS[type] ?? PAYMENT_CONFIGS.default;',
  '  return {',
  '    gateway: config.gateway,',
  '    status: config.status,',
  '    message: config.message(payment),',
  '    requiresRedirect: config.requiresRedirect',
  '  };',
  '});',
  '',
  '// Still orchestrating behaviour and rendering together',
  '<div class={`payment payment--${processing.status}`}>',
  '  <h3>{processing.message}</h3>',
  '  <p>Gateway: {processing.gateway}</p>',
  '</div>'
].join('\n');

export const strategyPaymentCode = [
  '// paymentStrategies.js',
  'export const createCreditCardStrategy = () => ({',
  "  id: 'creditcard',",
  "  label: 'Credit Card',",
  '  process(payment) {',
  '    return {',
  "      gateway: 'stripe',",
  "      status: 'processing',",
  '      message: `Processing $${payment.amount} via credit card`,',
  '      fee: payment.amount * (payment.processingFee / 100),',
  '      redirectUrl: payment.requiresAuth ? "/auth/3ds" : null',
  '    };',
  '  }',
  '});',
  '',
  'export const createPayPalStrategy = () => ({',
  "  id: 'paypal',",
  "  label: 'PayPal',",
  '  process(payment) {',
  '    return {',
  "      gateway: 'paypal',",
  "      status: 'redirect',",
  '      message: `$${payment.amount} via PayPal Express`,',
  '      fee: payment.amount * (payment.processingFee / 100),',
  '      redirectUrl: "/gateway/paypal"',
  '    };',
  '  }',
  '});',
  '',
  'export const strategies = [',
  '  createCreditCardStrategy(),',
  '  createPayPalStrategy(),',
  '  // Add new payment methods without touching the consumer component',
  '];',
  '',
  '// PaymentProcessor.strategy.svelte',
  "import { strategies } from './paymentStrategies.js';",
  '',
  'let {',
  '  payment,',
  "  activeStrategyId = 'creditcard',",
  '  onPaymentResult = undefined',
  '} = $props();',
  '',
  'const registry = new Map(strategies.map((strategy) => [strategy.id, strategy]));',
  'let activeStrategy = $state(registry.get(activeStrategyId));',
  '',
  'function setStrategy(id) {',
  '  const strategy = registry.get(id);',
  '  if (!strategy) return;',
  '  activeStrategy = strategy;',
  '}',
  '',
  'const result = $derived(() => activeStrategy?.process(payment));',
  '',
  '$effect(() => {',
  '  if (result && onPaymentResult) {',
  '    onPaymentResult(result);',
  '  }',
  '});',
  '',
  '{#snippet defaultSlot()}',
  '  <div class={`payment payment--${result?.status ?? "pending"}`}>',
  '    <h3>{result?.message}</h3>',
  '    <p>Fee: ${result?.fee?.toFixed(2)}</p>',
  '    {#if result?.redirectUrl}',
  '      <button onclick={() => window.location.href = result.redirectUrl}>',
  '        Continue Payment',
  '      </button>',
  '    {/if}',
  '  </div>',
  '{/snippet}'
].join('\n');

export const interfaceStrategyPaymentCode = [
  '// paymentStrategies.js',
  '',
  '/**',
  ' * @typedef {Object} PaymentResult',
  ' * @property {string} gateway - Payment gateway identifier',
  ' * @property {string} status - Processing status',
  ' * @property {string} message - User-facing message',
  ' * @property {number} fee - Processing fee amount',
  ' * @property {string|null} redirectUrl - URL for redirects',
  ' */',
  '',
  '/**',
  ' * @typedef {Object} PaymentStrategy',
  ' * @property {string} id - Unique strategy identifier',
  ' * @property {string} label - Human-readable name',
  ' * @property {function(Object): PaymentResult} process - Process payment',
  ' */',
  '',
  '/**',
  ' * Validates that an object implements PaymentStrategy interface',
  ' * @param {*} strategy - Object to validate',
  ' * @throws {Error} If strategy does not implement interface',
  ' */',
  'function validateStrategy(strategy) {',
  '  if (!strategy || typeof strategy !== "object") {',
  '    throw new Error("Strategy must be an object");',
  '  }',
  '  if (typeof strategy.id !== "string" || !strategy.id) {',
  '    throw new Error("Strategy must have a non-empty id string");',
  '  }',
  '  if (typeof strategy.label !== "string" || !strategy.label) {',
  '    throw new Error("Strategy must have a non-empty label string");',
  '  }',
  '  if (typeof strategy.process !== "function") {',
  '    throw new Error("Strategy must have a process function");',
  '  }',
  '}',
  '',
  '/**',
  ' * Creates a credit card payment strategy',
  ' * @returns {PaymentStrategy}',
  ' */',
  'export const createCreditCardStrategy = () => {',
  '  const strategy = {',
  '    id: "creditcard",',
  '    label: "Credit Card",',
  '    /**',
  '     * @param {Object} payment - Payment data',
  '     * @returns {PaymentResult}',
  '     */',
  '    process(payment) {',
  '      return {',
  '        gateway: "stripe",',
  '        status: "processing",',
  '        message: `Processing $${payment.amount} via credit card`,',
  '        fee: payment.amount * (payment.processingFee / 100),',
  '        redirectUrl: payment.requiresAuth ? "/auth/3ds" : null',
  '      };',
  '    }',
  '  };',
  '  validateStrategy(strategy);',
  '  return strategy;',
  '};',
  '',
  '/**',
  ' * Creates a PayPal payment strategy',
  ' * @returns {PaymentStrategy}',
  ' */',
  'export const createPayPalStrategy = () => {',
  '  const strategy = {',
  '    id: "paypal",',
  '    label: "PayPal",',
  '    /**',
  '     * @param {Object} payment - Payment data',
  '     * @returns {PaymentResult}',
  '     */',
  '    process(payment) {',
  '      return {',
  '        gateway: "paypal",',
  '        status: "redirect",',
  '        message: `$${payment.amount} via PayPal Express`,',
  '        fee: payment.amount * (payment.processingFee / 100),',
  '        redirectUrl: "/gateway/paypal"',
  '      };',
  '    }',
  '  };',
  '  validateStrategy(strategy);',
  '  return strategy;',
  '};',
  '',
  '/** @type {PaymentStrategy[]} */',
  'export const strategies = [',
  '  createCreditCardStrategy(),',
  '  createPayPalStrategy(),',
  '  // Add new strategies - validation ensures they implement interface',
  '];',
  '',
  '// PaymentProcessor.interface.svelte',
  'import { strategies } from "./paymentStrategies.js";',
  '',
  'let {',
  '  payment,',
  '  activeStrategyId = "creditcard",',
  '  onPaymentResult = undefined',
  '} = $props();',
  '',
  'const registry = new Map(strategies.map((s) => [s.id, s]));',
  'let activeStrategy = $state(registry.get(activeStrategyId));',
  '',
  'function setStrategy(id) {',
  '  const strategy = registry.get(id);',
  '  if (!strategy) return;',
  '  activeStrategy = strategy;',
  '}',
  '',
  '// TypeScript-like safety with runtime validation',
  'const result = $derived(() => {',
  '  if (!activeStrategy) return null;',
  '  try {',
  '    return activeStrategy.process(payment);',
  '  } catch (error) {',
  '    console.error("Strategy processing failed:", error);',
  '    return { gateway: "error", status: "failed", message: "Processing failed" };',
  '  }',
  '});'
].join('\n');

export const typescriptStrategyCode = [
  '// paymentStrategies.ts',
  '',
  'interface PaymentResult {',
  '  gateway: string;',
  '  status: string;',
  '  message: string;',
  '  fee: number;',
  '  redirectUrl: string | null;',
  '}',
  '',
  'interface PaymentStrategy {',
  '  id: string;',
  '  label: string;',
  '  process(payment: PaymentData): PaymentResult;',
  '}',
  '',
  'interface PaymentData {',
  '  amount: number;',
  '  currency: string;',
  '  method: string;',
  '  requiresAuth: boolean;',
  '  processingFee: number;',
  '}',
  '',
  'export const createCreditCardStrategy = (): PaymentStrategy => ({',
  '  id: "creditcard",',
  '  label: "Credit Card",',
  '  process(payment: PaymentData): PaymentResult {',
  '    return {',
  '      gateway: "stripe",',
  '      status: "processing",',
  '      message: `Processing $${payment.amount} via credit card`,',
  '      fee: payment.amount * (payment.processingFee / 100),',
  '      redirectUrl: payment.requiresAuth ? "/auth/3ds" : null',
  '    };',
  '  }',
  '});',
  '',
  'export const createPayPalStrategy = (): PaymentStrategy => ({',
  '  id: "paypal",',
  '  label: "PayPal",',
  '  process(payment: PaymentData): PaymentResult {',
  '    return {',
  '      gateway: "paypal",',
  '      status: "redirect",',
  '      message: `$${payment.amount} via PayPal Express`,',
  '      fee: payment.amount * (payment.processingFee / 100),',
  '      redirectUrl: "/gateway/paypal"',
  '    };',
  '  }',
  '});',
  '',
  'export const strategies: PaymentStrategy[] = [',
  '  createCreditCardStrategy(),',
  '  createPayPalStrategy(),',
  '  // TypeScript ensures all strategies implement the interface',
  '];',
  '',
  '// PaymentProcessor.svelte',
  '<script lang="ts">',
  '  import { strategies } from "./paymentStrategies.js";',
  '  import type { PaymentData, PaymentStrategy } from "./paymentStrategies.js";',
  '',
  '  interface Props {',
  '    payment: PaymentData;',
  '    activeStrategyId?: string;',
  '    onPaymentResult?: (result: PaymentResult) => void;',
  '  }',
  '',
  '  let {',
  '    payment,',
  '    activeStrategyId = "creditcard",',
  '    onPaymentResult',
  '  }: Props = $props();',
  '',
  '  const registry = new Map(strategies.map(s => [s.id, s]));',
  '  let activeStrategy = $state<PaymentStrategy | undefined>(',
  '    registry.get(activeStrategyId)',
  '  );',
  '',
  '  function setStrategy(id: string): void {',
  '    const strategy = registry.get(id);',
  '    if (strategy) {',
  '      activeStrategy = strategy;',
  '    }',
  '  }',
  '',
  '  // Compile-time type safety, no runtime validation needed',
  '  const result = $derived(() => {',
  '    return activeStrategy?.process(payment) ?? null;',
  '  });',
  '',
  '  $effect(() => {',
  '    if (result && onPaymentResult) {',
  '      onPaymentResult(result);',
  '    }',
  '  });',
  '</script>'
].join('\n');

export const stages = [
  {
    id: 'naive',
    label: 'Na√Øve conditionals',
    emoji: 'üß±',
    summary: 'All payment logic lives inside the component with nested conditionals and duplicated processing.',
    painPoints: [
      'Payment processing and UI logic welded together',
      'Hard to add new payment methods without regressions',
      'Impossible to reuse payment logic elsewhere'
    ],
    code: naivePaymentCode
  },
  {
    id: 'branching',
    label: 'Switch statement',
    emoji: 'üîÄ',
    summary: 'Extracts payment type detection, but keeps the component responsible for all processing logic.',
    painPoints: [
      'Giant switch grows with every payment method',
      'Payment processing contract stays implicit',
      'Still violates single responsibility'
    ],
    code: branchingPaymentCode
  },
  {
    id: 'config',
    label: 'Configuration map',
    emoji: 'üóÇÔ∏è',
    summary: 'Moves payment details into a lookup table. Better reuse, but still leaks implementation details.',
    painPoints: [
      'Component still orchestrates payment behavior',
      'Config contract not enforced',
      'Side effects like redirects impossible to isolate'
    ],
    code: configPaymentCode
  },
  {
    id: 'strategy',
    label: 'Strategy pattern',
    emoji: 'üß†',
    summary: 'Payment processing behind a consistent interface. Strategies can be swapped, composed, and tested.',
    wins: [
      'Encapsulated payment algorithms with clear contract',
      'Easy to add new payment methods or experiments',
      'Side effects like redirects live inside strategies'
    ],
    code: strategyPaymentCode
  },
  {
    id: 'interface',
    label: 'Strategy with interface',
    emoji: 'üìã',
    summary: 'Strategy pattern with explicit interface definition using JSDoc and runtime validation.',
    wins: [
      'Explicit contract definition with JSDoc comments',
      'Runtime validation prevents malformed strategies',
      'Better developer experience with IntelliSense',
      'Self-documenting code with type annotations'
    ],
    code: interfaceStrategyPaymentCode
  },
  {
    id: 'typescript',
    label: 'TypeScript interfaces',
    emoji: 'üî∑',
    summary: 'Clean, concise interfaces with compile-time safety. No runtime validation needed.',
    wins: [
      'Concise interface definitions without verbose JSDoc',
      'Compile-time type checking prevents errors early',
      'Superior developer experience with auto-completion',
      'No runtime overhead - validation happens at build time'
    ],
    code: typescriptStrategyCode
  }
];